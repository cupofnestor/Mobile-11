package  {		import Box2DAS.*;	import Box2DAS.Collision.*;	import Box2DAS.Collision.Shapes.*;	import Box2DAS.Common.*;	import Box2DAS.Dynamics.*;	import Box2DAS.Dynamics.Contacts.*;	import Box2DAS.Dynamics.Joints.*;	import cmodule.Box2D.*;	import wck.*;	import gravity.*;	import misc.*;	import flash.utils.*;	import flash.events.*;	import flash.display.*;	import flash.text.*;	import flash.geom.*;	import flash.ui.*;	import shapes.*	/**	 * Provides gravity that changes direction along an axis based on a sine wave.	 */	public class GravityWave extends Gravity {				public var waveLen:Number;		public var i:Number = 0;		public var v:V2;		private var r:Rectangle		public override function create():void {			visible = false;			world = Util.findAncestorOfClass(this, wck.World) as wck.World;			world.ensureCreated();			if(sensorName != '') {				var sensor:ShapeBase = Util.getDisplayObjectByPath(world, sensorName, world) as ShapeBase;				if(sensor) {					sensor.reportBeginContact = true;					sensor.reportEndContact = true;					sensor.ensureCreated();					listenWhileVisible(sensor, ContactEvent.BEGIN_CONTACT, handleBeginContact);					listenWhileVisible(sensor, ContactEvent.END_CONTACT, handleEndContact);				}			}			else {				world.customGravity = this;			}			base = new V2(10, 0);			listenWhileVisible(world, StepEvent.STEP, initStep, false, 15);			this.visible=true;			r = Util.bounds(this.world);			waveLen = r.width / 2;		}				public override function initStep(e:Event):void {									v = V2.rotate(base, rotation * Util.D2R);			i+=0.01;					}				/**		 *		 */		public override function gravity(p:V2, b:b2Body = null, b2:BodyShape = null):V2 {			trace("GRAV::");			/// Transform the point into the local coordinate space.			var lp:Point = Util.localizePoint(this, world, V2.multiplyN(p, world.scale).toP());			/// Get an angle based on the x coordinate.			var a:Number = lp.x / waveLen * Math.PI;			a+=i;			/// Rotate base gravity.			return V2.rotate(v, a);		}	}}