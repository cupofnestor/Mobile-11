package com.mobile.signalFlags {		import flash.display.MovieClip;	import fl.transitions.*;	import fl.transitions.easing.*;	import fl.motion.easing.*;	import flash.filters.*;	import caurina.transitions.*;	import flash.events.KeyboardEvent ;	import flash.events.Event;	import com.nestor.elements.soundLoop;	import com.nestor.elements.bitmapScroll;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import com.nestor.elements.maskedDisplacement;		public class ship extends MovieClip {		var totalFlags:int=10;		var spacing:Number = 10;		var flag_meta:MovieClip;		//var flagArray:Array = [];		var poleArray:Array = new Array();		var n:Number=0;		var poleI:Number=0;		var mesArray:Array = new Array();		var flagCheck:Boolean = false;		var sea:soundLoop;		var creak:soundLoop;		var sails:Array = new Array();		var sailsActive:Boolean = true;		//add To config???		var seaSound:String="snd/sea.mp3"		var seaV:Number=0.1;		var sky:bitmapScroll = new bitmapScroll();		var ironsides:bitmapScroll = new bitmapScroll();		var creakSound:String="snd/creak.mp3"		var creakV:Number=0.3;		var instructPaper:paper = new paper();		private var _kbActive:Boolean = false;				//add to config		var doubleErrorH:String = "<h1> Sorry... <p><br /></p><h2> You've already used this flag.</h2> <p><br /></p> <li>You must use a<span class = \"bold\"> REPEATER </span>flag to repeat a character, since you only have one set of flags to compose your message.</li>  <p><br /></p> <li>For more information, please push <span class =\"bold\">Exit</span>, then the button marked <span class=\"bold\">Explore the Flags.</span></li>";				var wallpaper:Bitmap;				public function ship() {			// constructor code			//this.dim = 0;			this.debugField.visible=false;						sea = new soundLoop(seaSound,seaV);			sea.addEventListener(Event.COMPLETE,sndReady);						creak = new soundLoop(creakSound,creakV);			creak.addEventListener(Event.COMPLETE,sndReady);						addEventListener(Event.ADDED_TO_STAGE, init);		}				public function set kbActive(b:Boolean):void		{			_kbActive = b;			(b) ? activateKeyboard() : deactivateKeyboard();		}				public function set directions(s:String):void		{						instructPaper = new paper();			instructPaper.display(s,999,false);			addChild(instructPaper);		}				private function activateKeyboard():void		{			(_kbActive && !(stage.hasEventListener(KeyboardEvent.KEY_DOWN))) ? stage.addEventListener(KeyboardEvent.KEY_DOWN, addFlag) : null;					}				private function deactivateKeyboard():void		{			(stage.hasEventListener(KeyboardEvent.KEY_DOWN)) ? stage.removeEventListener(KeyboardEvent.KEY_DOWN, addFlag) : null;		}				public function resetShip():void		{			flagCheck = false;			instructPaper.off();			poleI=0;			this.pole1.resetPole();			this.pole2.resetPole();		}				private function sndReady(e:Event):void		{			e.target.startLoop();		}						private function init(e:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, init);			poleArray = [this.pole1,this.pole2];			poleArray[poleI].addEventListener("poleFull", nextPole);			poleArray[poleI].addEventListener("resetKeyboard", poleResetKb);												buildSails();						scrollBG();		}				private function buildSails():void		{			for (var i:Number = this.anim.move.numChildren-1; i > 0 ; i--)			{				var tmp:DisplayObject = this.anim.move.getChildAt(i);				(tmp is maskedDisplacement) ? sails.push(tmp as maskedDisplacement) : null;			}		}				public function set sailsAreActive(b:Boolean):void		{ 			sailsActive = b;			for each (var md:maskedDisplacement in sails)			{				md.animate = sailsActive;			}			sky.active = b;			ironsides.active = b;		}				private function get sailsAreActive():Boolean		{			return sailsActive;		}				private function scrollBG():void		{			var tmp_bg:MovieClip = this.anim.move.BG;			sky.speed_y = 0;			sky.scrollMC =tmp_bg;			this.anim.move.BG.addChild(sky);			sky.active = true;						tmp_bg = this.anim.move.ironsides;			ironsides.speed_y = 0;			ironsides.speed_x = 3;			ironsides.scrollMC = tmp_bg;			this.anim.move.ironsides.addChild(ironsides);			this.anim.move.ironsides.removeChildAt(0);			ironsides.active = true;		}				public function addFlag(e:KeyboardEvent):void{			//trace("::SHIP:: checkingKey");			//stage.removeEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			kbActive = false;						var keyNum = e.charCode;			switch (keyNum) {				case 13:					messageComplete(e)					break;				case 9:					exit();					break;				case 8:					backspace();					break;				case 127:					backspace();					break;				default:									if (keyNum >= 48 && keyNum <= 57) parseFlagKey(String.fromCharCode(keyNum));					else if (keyNum >=97 && keyNum <= 124) parseFlagKey(String.fromCharCode(keyNum));					else if (keyNum == 33 || keyNum == 64) parseFlagKey(String.fromCharCode(keyNum));					else if (keyNum >=35 && keyNum <= 36) parseFlagKey(String.fromCharCode(keyNum));					else badKey(e);								} 					}				function parseFlagKey(_keyPressed):void		{			//trace("::SHIP:: does "+_keyPressed+"=="+poleArray[poleI].word+"??");			//for each (var str:String in mesArray) {  // old check for multiple poles			for each (var str:String in poleArray[poleI].word) {  // old check for multiple poles				flagCheck = (str == _keyPressed) ? true : false;												//trace("::SHIP:: "+_keyPressed+" == "+str+"?? :: "+flagCheck);				if (flagCheck == true)  break ;			} 						if (flagCheck == false){				//trace("::SHIP:: NO, pushing array.");				//mesArray.push(_keyPressed);								poleArray[poleI].addFlag(_keyPressed);				this.debugField.text="mesArray :: "+poleArray[0].word+"::"+poleArray[1].word;			}			else if (flagCheck == true){				//trace("::SHIP:: YES, redundancy found.");				paperMessage(doubleErrorH,8000);							}		}		private function badKey(e:Event):void		{			//trace("::SHIP:: BAD KEY:"+e);			resetHandler();		}				private function poleResetKb(e:Event):void		{			kbActive = true;;		}				private function resetHandler():void{			//dispatchEvent(new Event("resetKeyboard", true));			kbActive = true;		}				private function nextPole(e:Event):void		{			poleArray[poleI].removeEventListener("poleFull", nextPole);			poleArray[poleI].removeEventListener("resetKeyboard", poleResetKb);			poleI++;			poleArray[poleI].addEventListener("poleFull", messageComplete);			poleArray[poleI].addEventListener("resetKeyboard", poleResetKb);			kbActive = true;		}		private function messageComplete(e:Event):void		{			//keyboard is not active			kbActive = false;			dispatchEvent(new Event("messageComplete"));		}				function exit():void		{			//keyboard is not active			//kbActive == false;			dispatchEvent(new Event("exit"));			//paperMessage("Exiting... <br /> Guess you were bored.",500);					}				function backspace():void		{			poleArray[poleI].removeFlag();			this.debugField.text="mesArray :: "+poleArray[0].word+"::"+poleArray[1].word;			//dispatchEvent(new Event("backspace"));			//paperMessage("Backspace","Not Implemented Yet",500);		}				public function paperMessage(mess:String,time:Number=2000, exit:Boolean = true):paper		{			var thisPaper:paper = new paper();			thisPaper.display(mess,time,exit);			thisPaper.tY+= 500;			addChild(thisPaper);			thisPaper.addEventListener("paperOff", paperOffHandler);			return thisPaper;		}				private function paperOffHandler(p:Event):void		{			var pt:paper = p.target as paper			pt.removeEventListener("paperOff", paperOffHandler);			removeChild(pt);			pt=null;			resetHandler();		}				public function snap():BitmapData		{			var bmd:BitmapData = new BitmapData(stage.stageWidth, stage.stageHeight);			bmd.draw(this);			wallpaper = new Bitmap(bmd);			addChild(wallpaper);			//anim.alpha=1;			return bmd;		}				public function set dim(n:Number):void		{			Tweener.addTween(this.vignette, {alpha:n, time:1, transition:"linear"});		}									}	}//OG CODE/*																	*/