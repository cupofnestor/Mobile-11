package com.mobile.signalFlags {		import com.nestor.elements.maskedDisplacement;	import flash.events.Event;		public class water extends maskedDisplacement {		var lookup:Array=new Array();		var ct:Number = 0;		public function water() {			// constructor code			lookup = buildLookup();						super();			speedX = 3; 			speedY = 1;			channel = 1; 			flapX = 100; 			flapY = 10; 			baseX = 30; // size of noise in x axis			baseY = 4; // size of noise in y axis			octs = 1; // noise functions for noise (smaller = faster)			seed = Math.floor(Math.random() * 55); // random seed for noise			noiseWidth=200;			noiseLength=98;						link(this.water_mc, this.displace_mc);						build();			start();		}				override public function loop(evt:Event):void{			ct++;			ct = ct % 360;			speedY = lookup[ct];			super.loop(evt);								}				private function buildLookup():Array		{			var _cos:Array = new Array();			for (var i:Number = 0; i<360;i++){				var rad:Number = i * Math.PI/180;				_cos.push(Math.cos(rad));			}			return _cos;		}	}	}/*Stage.scaleMode = 'noScale';Here, perlin noise is used to create random waves in a movie clip that is used as a displacement map for aflag movie clip making it appear as though it is waving create a movie clip in displace_mc to draw perlin noise indisplace_mc.createEmptyMovieClip("perlin", 1);var wide:Number = displace_mc.width;var high:Number = displace_mc.height;var perlin:MovieClip = new MovieClip();displace_mc.addChildAt(perlin, 1); ramp is a movie clip already in displace_mc that is used to ease the perlin noise from non effective on the left side of the flag to fully effective on the rightvar ramp:MovieClip = this.water_mc.displace_mc.rampramp.swapDepths(2); // place ramp above perlin noisevar ramp:MovieClip = displace_mc.ramp;displace_mc.swapChildren(perlin, ramp); ** 50% red is no displacement in the displacement map the ramp goes from 50% red to transparent letting the perlin noise show through as you move further right GENERAL variablesvar speed = 3;  speed at which noise is shifted (causes flap)var channel = 1;  red - red used to displace pixels along  DISPLACEMENT variablesvar flapX = 100;  power of pixel displacement along x axisvar flapY = 10;  power of pixel displacement along y axisvar mode = "ignore";  clamp the image so none of the original is seen ** inside the flag movie clip there is an invisible border that is used to extend the bounds of the clip beyond that of the flag image this lets the displacement map extend further past the extents of the flagvar offset = new flash.geom.Point(0, 0);  displacment map offset create BitmapData object encompasing the size of the displace ramp for the displacement and create a displace filter that uses itvar displaceBitmap:BitmapData = new BitmapData(wide, high);var displaceFilter:DisplacementMapFilter = new DisplacementMapFilter(displaceBitmap, offset, channel, channel, flapX, flapY, mode); PERLINNOISE variablesvar baseX = 30;  size of noise in x axisvar baseY = 4;  size of noise in y axisvar octs = 1;  noise functions for noise (smaller = faster)var seed = Math.floor(Math.random() * 50);  random seed for noisevar stitch = true;  stitching makes the noise wrap making it easy to repeatvar fractal = true;  use fractal noisevar gray = true;  grayscale is not used because the red channel is create BitmapData object for the noise and apply perlinNoise.  It will be repeated along y so it  only needs to be 1 pixel high.  How long it is determines the variants of noise produced.  With the stitching and thanks to beginGradientFill, we will just loop the noise over time.var noiseBitmap:BitmapData = new BitmapData(200, 100);noiseBitmap.perlinNoise(baseX, baseY, octs, seed, stitch, fractal, channel, gray); the shift matrix allows for the noise to be moved over time using beginBitmapFill since the noise is only created once and just looped for the flag effectvar shift:Matrix = new Matrix();stage.addEventListener(Event.ENTER_FRAME,loop);displace_mc.visible = false; every framefunction loop(evt:Event):void{		 move the matrix by speed along x to shift the noise	shift.translate(speed, 0);		 drawing in the perlin movie clip,	 create a rectangle with the perlin noise	 drawn in it with an offset supplied by the	 shift matrix	with (this.displace_mc.graphics){		clear();		beginBitmapFill(noiseBitmap, shift);		moveTo(0,0);		lineTo(wide, 0);		lineTo(wide, high);		lineTo(0, wide);		lineTo(0, 0);		endFill();	}					 draw the displacement movie clip in the 	 displaceBitmap (used in displaceFilter)	displaceBitmap.draw(displace_mc);	 apply displaceFilter to the flag	water_mc.filters = [displaceFilter];}stage.addEventListener(MouseEvent.MOUSE_DOWN, down);stage.addEventListener(MouseEvent.MOUSE_UP, up);// show the displacement image when the mouse is pressedfunction down(evt:MouseEvent):void{	displace_mc.visible = true;	water_mc.visible = false;}// go back to showing main image when the mouse is releasedfunction up(evt:MouseEvent):void{	displace_mc.visible = false;	water_mc.visible = true;}*/